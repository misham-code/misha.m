FUNCTION /skn/f_so_st_get_delta.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(SW_CLIENT) TYPE  /SKN/E_SW_CLIENT OPTIONAL
*"     VALUE(IM_SI_ID) TYPE  /SKN/E_SO_SI_ID OPTIONAL
*"     VALUE(IM_SI_VER) TYPE  /SKN/E_SO_SI_ID_VER OPTIONAL
*"     VALUE(IM_RUN_NO_TARGET) TYPE  /SKN/E_SO_RUN_NO OPTIONAL
*"     VALUE(IM_RUN_NO_SOURCE) TYPE  /SKN/E_SO_RUN_NO OPTIONAL
*"  EXPORTING
*"     VALUE(ST_ID) TYPE  /SKN/E_SO_ST_ID
*"     VALUE(ST_DESC) TYPE  /SKN/E_SO_ST_DESC
*"     VALUE(START_DATE) TYPE  /SKN/E_SO_LG_DATE
*"     VALUE(START_TIME) TYPE  /SKN/E_SO_LG_TIME
*"     VALUE(ST_STATE) TYPE  /SKN/E_SO_TASK_STATE
*"     VALUE(SI_ID) TYPE  /SKN/E_SO_SI_ID
*"     VALUE(SI_VER) TYPE  /SKN/E_SO_SI_ID_VER
*"     VALUE(END_DATE) TYPE  /SKN/E_SO_LG_DATE
*"     VALUE(END_TIME) TYPE  /SKN/E_SO_LG_TIME
*"     VALUE(SW_SY) TYPE  /SKN/E_SW_SYSTEM
*"     VALUE(SO_PROCESS) TYPE  /SKN/E_SO_PROCESS
*"     VALUE(EX_MESSAGES) TYPE  /SKN/TT_MESSAGES
*"  TABLES
*"      T_SELECT STRUCTURE  RSSELECT OPTIONAL
*"      SO_DATA_STRUCTURE STRUCTURE  /SKN/S_SO_S_FCAT OPTIONAL
*"      SO_DELTA_SOURCE OPTIONAL
*"      SO_DELTA_TARGET OPTIONAL
*"  EXCEPTIONS
*"      WRONG_PARAMETERS
*"      NO_DATA
*"----------------------------------------------------------------------
  " ===================================================================
  " CONSTANTS DEFINITION
  " ===================================================================

  CONSTANTS: c_finished_state TYPE c LENGTH 1 VALUE 'F',         " Finished run state
             c_format_only    TYPE c LENGTH 1 VALUE 'X',         " Get format only
             c_get_data       TYPE c LENGTH 1 VALUE ' ',         " Get actual data
             c_end_marker     TYPE c LENGTH 3 VALUE 'END',       " End of processing marker
             c_min_runs       TYPE i VALUE 2.                    " Minimum runs required

  CONSTANTS: c_message_type_e TYPE /skn/e_message_type VALUE 'E', "  Error Message
             c_message_type_w TYPE /skn/e_message_type VALUE 'W',  "  Warning Message
             c_message_type_i TYPE /skn/e_message_type VALUE 'I'.  "  Information Message

  " ===================================================================
  " TYPE DEFINITIONS
  " ===================================================================

  " Enhanced run information structure
  TYPES: BEGIN OF ty_run_info,
           run_no     TYPE /skn/e_so_run_no,
         END OF ty_run_info.

  TYPES: tt_run_info TYPE STANDARD TABLE OF ty_run_info WITH NON-UNIQUE KEY run_no.

  " ===================================================================
  " DATA DECLARATIONS
  " ===================================================================

  " Run management variables
  DATA: lt_available_runs TYPE tt_run_info,                      " All available runs
        ls_source_run     TYPE ty_run_info,                      " Source run (older)
        ls_target_run     TYPE ty_run_info,                      " Target run (newer)
        lv_run_count      TYPE i,                                " Number of available runs
        lv_si_id_source   TYPE /skn/e_so_si_id,
        lv_si_ver_source  TYPE /skn/e_so_si_id_ver,
        lv_si_id_target   TYPE /skn/e_so_si_id,
        lv_si_ver_target  TYPE /skn/e_so_si_id_ver,
        lv_si_id          TYPE /skn/e_so_si_id,
        lv_si_ver         TYPE /skn/e_so_si_id_ver.

  " Loop control and comparison variables
  DATA: lv_source_index   TYPE i,                                " Current source table index
        lv_target_index   TYPE i,                                " Current target table index
        lv_source_lines   TYPE i,                                " Total source table lines
        lv_target_lines   TYPE i.                                " Total target table lines

  " Dynamic structure management
  DATA: lt_field_catalog       TYPE STANDARD TABLE OF /skn/s_so_s_fcat,  " Field definitions
        ls_field_catalog       TYPE /skn/s_so_s_fcat,                     " Single field entry
        lr_structure_type      TYPE REF TO data,                          " Dynamic structure reference
        lr_table_type          TYPE REF TO data.                          " Dynamic table reference

  " Function call management and error handling
  DATA: lv_function_rc         TYPE sy-subrc,                             " Function return code
        lv_message             TYPE string,                               " Error message text
        ls_messages        TYPE  /skn/s_messages.           " Export Messages structure

  " Field symbols for dynamic data handling
  FIELD-SYMBOLS: <lt_source_data>   TYPE STANDARD TABLE,                  " Source dataset
                 <ls_source_record> TYPE any,                             " Source record structure
                 <lt_target_data>   TYPE STANDARD TABLE,                  " Target dataset
                 <ls_target_record> TYPE any.                             " Target record structure

  " ===================================================================
  " INITIALIZATION AND INPUT VALIDATION
  " ===================================================================

  " Clear all export parameters to ensure clean output
  CLEAR: st_id, st_desc, start_date, start_time, st_state,
         si_id, si_ver, end_date, end_time, sw_sy, so_process.

  " Initialize output tables
  REFRESH: so_data_structure, so_delta_target, so_delta_source.




  " ===================================================================
  " STEP 1: RETRIEVE AND VALIDATE AVAILABLE RUNS
  " ===================================================================
  CLEAR: lv_si_id_source, lv_si_ver_source,
         lv_si_id_target, lv_si_ver_target.
  IF NOT im_run_no_source IS INITIAL.
    SELECT SINGLE si_id  si_ver
     FROM /skn/t_so_st
   INTO (lv_si_id_source, lv_si_ver_source)
   WHERE st_state  = @c_finished_state
     AND sw_client = @sw_client
     AND run_no     = @im_run_no_source.
    IF sy-subrc <>  0.
      lv_message = |No source run  found for client { sw_client }, source run_no { im_run_no_source }|.
      ls_messages-message  = lv_message.
      ls_messages-type = c_message_type_e.
      APPEND ls_messages TO ex_messages.
      EXIT.
*      RAISE wrong_parameters.
    ENDIF.
  ENDIF.
  IF NOT im_run_no_target IS INITIAL.
    SELECT SINGLE si_id  si_ver
     FROM /skn/t_so_st
   INTO (lv_si_id_target, lv_si_ver_target)
   WHERE st_state  = @c_finished_state
     AND sw_client = @sw_client
     AND run_no     = @im_run_no_target.
    IF sy-subrc <>  0.
      lv_message = |No TARGET run  found for client { sw_client }, TARGET run_no { im_run_no_target }|.
      ls_messages-message  = lv_message.
      ls_messages-type = c_message_type_e.
      APPEND ls_messages TO ex_messages.
      EXIT.
*      RAISE wrong_parameters.
    ENDIF.
  ENDIF.
  IF NOT im_run_no_source IS INITIAL AND
     NOT im_run_no_target IS INITIAL AND
    ( lv_si_id_source <> lv_si_id_target OR
      lv_si_ver_source <> lv_si_ver_target ).
    CONCATENATE 'runs has different  si_id or si_ver  TARGET : si_id = ' lv_si_id_target ' si_ver = ' lv_si_ver_target
     ' SOURCE : si_id = ' lv_si_id_source ' si_ver = ' lv_si_ver_source INTO lv_message.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE wrong_parameters.
  ENDIF.
  IF NOT im_run_no_source IS INITIAL.
    lv_si_id = lv_si_id_source.
    lv_si_ver = lv_si_ver_source.
  ELSEIF NOT im_run_no_target IS INITIAL.
    lv_si_id = lv_si_id_target.
    lv_si_ver = lv_si_ver_target.
  ELSE.
    lv_si_id = im_si_id.
    lv_si_ver = im_si_ver.
  ENDIF.
  IF NOT im_run_no_source IS INITIAL AND
     NOT im_run_no_target IS INITIAL.
    ls_source_run-run_no  = im_run_no_source.
    ls_target_run-run_no  = im_run_no_target.
  ELSE.
    " Query database for all completed runs matching criteria
    " Only consider runs with status 'F' (Finished) for data consistency
    SELECT run_no
        FROM /skn/t_so_st
      INTO CORRESPONDING FIELDS OF TABLE lt_available_runs
      WHERE st_state  = @c_finished_state
        AND sw_client = @sw_client
        AND si_id     = @lv_si_id
        AND si_ver    = @lv_si_ver
      ORDER BY run_no ASCENDING.                                   " Sort by run number for processing

    " Validate that sufficient data exists for comparison
    lv_run_count = lines( lt_available_runs ).

    IF lv_run_count = 0.
      lv_message = |No completed runs found for client { sw_client }, SI_ID { im_si_id }, version { im_si_ver }|.
      ls_messages-message  = lv_message.
      ls_messages-type = c_message_type_e.
      APPEND ls_messages TO ex_messages.
      EXIT.
*      RAISE no_data.
    ENDIF.

    IF lv_run_count < c_min_runs.
      lv_message = |Only { lv_run_count } run(s) found. Minimum { c_min_runs } runs required for delta comparison|.
      ls_messages-message  = lv_message.
      ls_messages-type = c_message_type_e.
      APPEND ls_messages TO ex_messages.
      EXIT.
*      RAISE no_data.
    ENDIF.

    " ===================================================================
    " STEP 2: DETERMINE SOURCE AND TARGET RUNS FOR COMPARISON
    " ===================================================================

    IF im_run_no_target IS NOT INITIAL.
      " Specific run number provided - validate existence and find predecessor
      READ TABLE lt_available_runs INTO ls_target_run
           WITH KEY run_no = im_run_no_target.

      IF sy-subrc <> 0.
        lv_message = |Specified run number { im_run_no_target } not found in available runs|.
        ls_messages-message  = lv_message.
        ls_messages-type = c_message_type_e.
        APPEND ls_messages TO ex_messages.
        EXIT.
*        RAISE wrong_parameters.
      ENDIF.

      lv_target_index = sy-tabix.

      " Ensure there's a previous run for comparison
      IF lv_target_index = 1.
        lv_message = |Run { im_run_no_target } is the first run. No previous run available for comparison|.
        ls_messages-message  = lv_message.
        ls_messages-type = c_message_type_e.
        APPEND ls_messages TO ex_messages.
        EXIT.
*        RAISE no_data.
      ENDIF.

      " Get the immediately preceding run
      READ TABLE lt_available_runs INTO ls_source_run INDEX ( lv_target_index - 1 ).

    ELSEIF  im_run_no_source IS NOT INITIAL.
      READ TABLE lt_available_runs INTO ls_source_run
           WITH KEY run_no = im_run_no_source.

      IF sy-subrc <> 0.
        lv_message = |Specified run number { im_run_no_source } not found in available runs|.
        ls_messages-message  = lv_message.
        ls_messages-type = c_message_type_e.
        APPEND ls_messages TO ex_messages.
        EXIT.
*        RAISE wrong_parameters.
      ENDIF.

      lv_source_index = sy-tabix.

      " Ensure there's a previous run for comparison
      IF lv_source_index = lv_run_count.
        lv_message = |Run { im_run_no_source } is the last run. No next run available for comparison|.
        ls_messages-message  = lv_message.
        ls_messages-type = c_message_type_e.
        APPEND ls_messages TO ex_messages.
        EXIT.
*        RAISE no_data.
      ENDIF.

      " Get the immediately preceding run
      READ TABLE lt_available_runs INTO ls_target_run INDEX ( lv_source_index + 1 ).

    ELSE.
      " No specific run provided - use the two most recent runs
      READ TABLE lt_available_runs INTO ls_target_run INDEX lv_run_count.        " Most recent
      READ TABLE lt_available_runs INTO ls_source_run INDEX ( lv_run_count - 1 ). " Second most recent
    ENDIF.

    " Log comparison details for debugging
    lv_message = |Delta comparison: Source run { ls_source_run-run_no } vs Target run { ls_target_run-run_no }|.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_i.
    APPEND ls_messages TO ex_messages.
  ENDIF.
  " ===================================================================
  " STEP 3: RETRIEVE FIELD CATALOG FROM SOURCE RUN
  " ===================================================================

  " Get structure definition from source run to ensure consistent comparison
  " This ensures both datasets have the same field structure
  CALL FUNCTION '/SKN/F_SO_ST_GET_DATA'
    EXPORTING
      sw_client         = sw_client
      run_no            = ls_source_run-run_no
      format_only       = c_format_only                         " Only retrieve metadata
    TABLES
      so_data_structure = lt_field_catalog
    EXCEPTIONS
      wrong_parameters  = 1
      no_data           = 2
      OTHERS            = 3.

  lv_function_rc = sy-subrc.
  IF lv_function_rc <> 0.
    lv_message = |Failed to retrieve field catalog from source run { ls_source_run-run_no }. RC: { lv_function_rc }|.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE no_data.
  ENDIF.

  " Validate field catalog contains data
  IF lines( lt_field_catalog ) = 0.
    lv_message = |Empty field catalog retrieved from source run { ls_source_run-run_no }|.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE no_data.
  ENDIF.

  " ===================================================================
  " STEP 4: CREATE DYNAMIC DATA STRUCTURES for source run
  " ===================================================================

  " Generate runtime data structures based on field catalog
  " This allows handling different data structures dynamically
  CALL FUNCTION '/SKN/F_SO_GENERATE_STRUCT'
    EXPORTING
      field_catalog             = lt_field_catalog
    IMPORTING
      ref_to_struct             = lr_structure_type             " Single record structure
      tab_ref_of_struct         = lr_table_type                " Internal table structure
    EXCEPTIONS
      generation_error          = 1
      generate_subpool_dir_full = 2
      OTHERS                    = 3.

  lv_function_rc = sy-subrc.
  IF lv_function_rc = 0.
    " Assign field symbols to generated structures
    ASSIGN lr_table_type->* TO <lt_source_data>.
    ASSIGN lr_structure_type->* TO <ls_source_record>.


  ELSE.
    lv_message = |Failed to generate dynamic structures. RC: { lv_function_rc }|.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE wrong_parameters.
  ENDIF.

  " Validate field symbol assignments
  IF <lt_source_data> IS NOT ASSIGNED.
    lv_message = 'Failed to assign field symbols to dynamic structures'.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE wrong_parameters.
  ENDIF.

  " ===================================================================
  " STEP 5: (Removed) Redundant target field catalog retrieval
  " Using the source run's field catalog for both source and target structures

  " ===================================================================
  " STEP 6: CREATE DYNAMIC DATA STRUCTURES for target  run
  " ===================================================================

  " Generate runtime data structures based on field catalog
  " This allows handling different data structures dynamically
  CALL FUNCTION '/SKN/F_SO_GENERATE_STRUCT'
    EXPORTING
      field_catalog             = lt_field_catalog
    IMPORTING
      ref_to_struct             = lr_structure_type             " Single record structure
      tab_ref_of_struct         = lr_table_type                " Internal table structure
    EXCEPTIONS
      generation_error          = 1
      generate_subpool_dir_full = 2
      OTHERS                    = 3.

  lv_function_rc = sy-subrc.
  IF lv_function_rc = 0.
    " Assign field symbols to generated structures
    ASSIGN lr_table_type->* TO <lt_target_data>.
    ASSIGN lr_structure_type->* TO <ls_target_record>.

  ELSE.
    lv_message = |Failed to generate dynamic structures. RC: { lv_function_rc }|.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE wrong_parameters.
  ENDIF.

  " Validate field symbol assignments
  IF  <lt_target_data> IS NOT ASSIGNED.
    lv_message =  'Failed to assign field symbols to dynamic structures'.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE wrong_parameters.
  ENDIF.


  " ===================================================================
  " STEP 7: LOAD SOURCE DATASET (OLDER RUN)
  " ===================================================================

  " Retrieve actual data from source run
  CALL FUNCTION '/SKN/F_SO_ST_GET_DATA'
    EXPORTING
      sw_client        = sw_client
      run_no           = ls_source_run-run_no
      format_only      = c_get_data                              " Retrieve actual data
    TABLES
      so_data          = <lt_source_data>
    EXCEPTIONS
      wrong_parameters = 1
      no_data          = 2
      OTHERS           = 3.

  lv_function_rc = sy-subrc.
  IF lv_function_rc <> 0.
    lv_message = |Failed to load data from source run { ls_source_run-run_no }. RC: { lv_function_rc }|.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE no_data.
  ENDIF.

  " Sort source data for efficient merge comparison
  SORT <lt_source_data>.
  lv_source_lines = lines( <lt_source_data> ).

  " ===================================================================
  " STEP 8: LOAD TARGET DATASET WITH METADATA (NEWER RUN)
  " ===================================================================

  " Retrieve data and metadata from target run
  CALL FUNCTION '/SKN/F_SO_ST_GET_DATA'
    EXPORTING
      sw_client         = sw_client
      run_no            = ls_target_run-run_no
      format_only       = c_get_data                              " Retrieve actual data
    IMPORTING
      st_id             = st_id                                   " Export all metadata
      st_desc           = st_desc
      start_date        = start_date
      start_time        = start_time
      st_state          = st_state
      si_id             = si_id
      si_ver            = si_ver
      end_date          = end_date
      end_time          = end_time
      sw_sy             = sw_sy
      so_process        = so_process
    TABLES
      t_select          = t_select
      so_data_structure = so_data_structure
      so_data           = <lt_target_data>
    EXCEPTIONS
      wrong_parameters  = 1
      no_data           = 2
      OTHERS            = 3.

  lv_function_rc = sy-subrc.
  IF lv_function_rc <> 0.
    lv_message = |Failed to load data from target run { ls_target_run-run_no }. RC: { lv_function_rc }|.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_e.
    APPEND ls_messages TO ex_messages.
    EXIT.
*    RAISE no_data.
  ENDIF.

  " Sort target data for efficient merge comparison
  SORT <lt_target_data>.
  lv_target_lines = lines( <lt_target_data> ).

  " ===================================================================
  " STEP 9: PERFORM OPTIMIZED DELTA MERGE COMPARISON
  " ===================================================================

  " This implements an optimized merge algorithm on sorted data
  " Time Complexity: O(n + m) where n and m are the sizes of source and target tables
  " Space Complexity: O(k) where k is the number of delta records


  " Initialize merge algorithm pointers
  lv_source_index = 1.
  lv_target_index = 1.
  IF lv_source_index <=  lv_source_lines.
    READ TABLE <lt_source_data> ASSIGNING <ls_source_record> INDEX lv_source_index.
    IF sy-subrc <> 0.
      " Unexpected error - source table should have this record
      EXIT.
    ENDIF.
  ENDIF.
  IF lv_target_index <=  lv_target_lines.
    READ TABLE <lt_target_data> ASSIGNING <ls_target_record> INDEX lv_target_index.
    IF sy-subrc <> 0.
      " Unexpected error - TARGET table should have this record
      EXIT.
    ENDIF.
  ENDIF.

  " Main merge loop - processes both tables in a single pass
  WHILE lv_target_index <= lv_target_lines OR
        lv_source_index <= lv_source_lines.
    IF lv_source_index >  lv_source_lines.
      APPEND <ls_target_record> TO so_delta_target.
      lv_target_index = lv_target_index + 1.
      READ TABLE <lt_target_data> ASSIGNING <ls_target_record> INDEX lv_target_index.
      CONTINUE.
    ENDIF.
    IF lv_target_index >  lv_target_lines.
      APPEND <ls_source_record> TO so_delta_source.
      lv_source_index = lv_source_index + 1.
      READ TABLE <lt_source_data> ASSIGNING <ls_source_record> INDEX lv_source_index.
      CONTINUE.
    ENDIF.


    " Perform three-way comparison using ABAP native comparison
    IF <ls_target_record> = <ls_source_record>.
      " Records are identical - no change detected
      " Advance both pointers to next records
      lv_source_index = lv_source_index + 1.
      lv_target_index = lv_target_index + 1.
      READ TABLE <lt_source_data> ASSIGNING <ls_source_record> INDEX lv_source_index.
      READ TABLE <lt_target_data> ASSIGNING <ls_target_record> INDEX lv_target_index.
      CONTINUE.
    ELSEIF <ls_target_record> > <ls_source_record>.
      " Target record is greater than source record
      " This means the source record was deleted in target run
      " Advance only source pointer
      APPEND <ls_source_record> TO so_delta_source.
      lv_source_index = lv_source_index + 1.
      READ TABLE <lt_source_data> ASSIGNING <ls_source_record> INDEX lv_source_index.
    ELSE.
      " Target record is less than source record
      " This means the target record is new (delta record)
      APPEND <ls_target_record> TO so_delta_target.
      lv_target_index = lv_target_index + 1.
      READ TABLE <lt_target_data> ASSIGNING <ls_target_record> INDEX lv_target_index.
    ENDIF.

  ENDWHILE.

  " ===================================================================
  " FINAL PROCESSING AND CLEANUP
  " ===================================================================

  " Log completion statistics
  DATA: lv_delta_count_source TYPE i,
        lv_delta_count_target TYPE i.

  lv_delta_count_target = lines( so_delta_target ).
  lv_delta_count_source = lines( so_delta_source ).

  lv_message = |Delta comparison completed. Source: { lv_source_lines } records, |
            && |Target: { lv_target_lines } records, Delta target: { lv_delta_count_target } records , Delta source: { lv_delta_count_source } records|.
  ls_messages-message  = lv_message.
  ls_messages-type = c_message_type_i.
  APPEND ls_messages TO ex_messages.

  " If no delta records found, this could be intentional or an issue
  IF lv_delta_count_source  = 0 and
    lv_delta_count_target  = 0.
    lv_message =  'No delta records found - datasets are identical'.
    ls_messages-message  = lv_message.
    ls_messages-type = c_message_type_i.
    APPEND ls_messages TO ex_messages.
  ENDIF.

ENDFUNCTION.